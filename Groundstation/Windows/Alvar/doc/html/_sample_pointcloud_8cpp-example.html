<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>SamplePointcloud.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  
  
  
   
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">SamplePointcloud.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>This is an example showing how to use <em>SimpleSfM</em> for tracking the environment using features in addition to <em>MultiMarker</em>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;CvTestbed.h&quot;</span>
<span class="preprocessor">#include &quot;GlutViewer.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="_sf_m_8h.html" title="This file implements structure from motion.">SfM.h</a>&quot;</span>
<span class="preprocessor">#include &quot;Shared.h&quot;</span>
<span class="keyword">using namespace </span>alvar;
<span class="keyword">using namespace </span>std;

<span class="keyword">const</span> <span class="keywordtype">double</span> marker_size=1;
<span class="keywordtype">bool</span> init=<span class="keyword">true</span>;
<a name="_a0"></a><a class="code" href="classalvar_1_1_simple_sf_m.html" title="Simple structure from motion implementation using CameraEC , MarkerDetectorEC and TrackerFeaturesEC...">SimpleSfM</a> *sfm;
std::stringstream calibrationFilename;

<span class="comment">// Own drawable 3D cross on features</span>
<span class="keyword">struct </span>OwnDrawable : <span class="keyword">public</span> Drawable {
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Draw() {
        <span class="keyword">const</span> <span class="keywordtype">double</span> scale = 0.2;
        glPushMatrix();
        glMultMatrixd(gl_mat);
        glColor3d(color[0], color[1], color[2]);
        glBegin(GL_LINES);
            glVertex3f(0.0, 0.0, -scale);
            glVertex3f(0.0, 0.0, scale);
            glVertex3f(0.0, -scale, 0.0);
            glVertex3f(0.0, scale, 0.0);
            glVertex3f(-scale, 0.0, 0.0);
            glVertex3f(scale, 0.0, 0.0);
        glEnd();
        glPopMatrix();
    }
};
Drawable d_marker;
OwnDrawable d_points[1000];
<span class="keywordtype">int</span> own_drawable_count;

<span class="keywordtype">bool</span> reset=<span class="keyword">false</span>;
<span class="keywordtype">void</span> videocallback(IplImage *image)
{
    <span class="keyword">static</span> IplImage *rgb = 0;
    <span class="keyword">static</span> IplImage* bg_image = 0;

    <span class="keywordtype">bool</span> flip_image = (image-&gt;origin?<span class="keyword">true</span>:<span class="keyword">false</span>);
    <span class="keywordflow">if</span> (flip_image) {
        cvFlip(image);
        image-&gt;origin = !image-&gt;origin;
    }

    <span class="keywordflow">if</span> (init) {
        init = <span class="keyword">false</span>;
        sfm-&gt;Clear();
        cout&lt;&lt;<span class="stringliteral">&quot;Loading calibration: &quot;</span>&lt;&lt;calibrationFilename.str();
        <span class="keywordflow">if</span> (sfm-&gt;GetCamera()-&gt;SetCalib(calibrationFilename.str().c_str(), image-&gt;width, image-&gt;height)) {
            cout&lt;&lt;<span class="stringliteral">&quot; [Ok]&quot;</span>&lt;&lt;endl;
        } <span class="keywordflow">else</span> {
            sfm-&gt;GetCamera()-&gt;SetRes(image-&gt;width, image-&gt;height);
            cout&lt;&lt;<span class="stringliteral">&quot; [Fail]&quot;</span>&lt;&lt;endl;
        }
        <span class="keywordtype">double</span> p[16];
        sfm-&gt;GetCamera()-&gt;GetOpenglProjectionMatrix(p,image-&gt;width,image-&gt;height);
        GlutViewer::SetGlProjectionMatrix(p);
        d_marker.SetScale(marker_size*2);
        rgb = CvTestbed::Instance().CreateImageWithProto(<span class="stringliteral">&quot;RGB&quot;</span>, image, 0, 3);
        CvTestbed::Instance().ToggleImageVisible(0, 0);
        bg_image = CvTestbed::Instance().CreateImage(<span class="stringliteral">&quot;BG texture&quot;</span>, cvSize(512,512),8, 3);
        bg_image-&gt;origin = 0;

        sfm-&gt;SetScale(10);
        <span class="keywordflow">if</span> (sfm-&gt;AddMultiMarker(<span class="stringliteral">&quot;mmarker.xml&quot;</span>, <a name="a1"></a><a class="code" href="namespacealvar.html#a89021fa008d0a93e735361ed4f3b885fa564f979051988b03ce9a266ee69bbe04" title="XML file format.">FILE_FORMAT_XML</a>)) {
            std::cout&lt;&lt;<span class="stringliteral">&quot;Using MultiMarker defined in mmarker.xml.&quot;</span>&lt;&lt;std::endl;
        } <span class="keywordflow">else</span> {
            std::cout&lt;&lt;<span class="stringliteral">&quot;Couldn&#39;t load mmarker.xml. Using default &#39;SampleMultiMarker&#39; setup.&quot;</span>&lt;&lt;std::endl;
            <a name="_a2"></a><a class="code" href="classalvar_1_1_pose.html" title="Pose representation derived from the Rotation class">Pose</a> pose;
            pose.<a name="a3"></a><a class="code" href="classalvar_1_1_pose.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a>();
            sfm-&gt;AddMarker(0, marker_size*2, pose);
            pose.<a name="a4"></a><a class="code" href="classalvar_1_1_pose.html#a13b8ab1ef3b2f42b5836dd75ad71a37d">SetTranslation</a>(-marker_size*2.5, +marker_size*1.5, 0);
            sfm-&gt;AddMarker(1, marker_size, pose);
            pose.<a class="code" href="classalvar_1_1_pose.html#a13b8ab1ef3b2f42b5836dd75ad71a37d">SetTranslation</a>(+marker_size*2.5, +marker_size*1.5, 0);
            sfm-&gt;AddMarker(2, marker_size, pose);
            pose.<a class="code" href="classalvar_1_1_pose.html#a13b8ab1ef3b2f42b5836dd75ad71a37d">SetTranslation</a>(-marker_size*2.5, -marker_size*1.5, 0);
            sfm-&gt;AddMarker(3, marker_size, pose);
            pose.<a class="code" href="classalvar_1_1_pose.html#a13b8ab1ef3b2f42b5836dd75ad71a37d">SetTranslation</a>(+marker_size*2.5, -marker_size*1.5, 0);
            sfm-&gt;AddMarker(4, marker_size, pose);
        }
        sfm-&gt;SetResetPoint();
    }
    <span class="keywordflow">if</span> (reset) {
        sfm-&gt;Reset();
        reset = <span class="keyword">false</span>;
    }

    <span class="comment">//if (sfm-&gt;UpdateRotationsOnly(image)) {</span>
    <span class="comment">//if (sfm-&gt;UpdateTriangulateOnly(image)) {</span>
    <span class="keywordflow">if</span> (sfm-&gt;Update(image, <span class="keyword">false</span>, <span class="keyword">true</span>, 7.f, 15.f)) {
        <span class="comment">// Draw the camera (The GlutViewer has little weirdness here...)q</span>
        <a class="code" href="classalvar_1_1_pose.html" title="Pose representation derived from the Rotation class">Pose</a> pose = *(sfm-&gt;GetPose());
        <span class="keywordtype">double</span> gl[16];
        pose.<a name="a5"></a><a class="code" href="classalvar_1_1_pose.html#a45351e3526097abd898da382c7f55935" title="Get the transformation matrix representation of the Pose using OpenGL&#39;s transposed format...">GetMatrixGL</a>(gl, <span class="keyword">true</span>);
        GlutViewer::SetGlModelviewMatrix(gl);
        pose.<a name="a6"></a><a class="code" href="classalvar_1_1_pose.html#acd68476b8afc6a2dcfb8663ead8b39cd">Invert</a>();
        pose.<a class="code" href="classalvar_1_1_pose.html#a45351e3526097abd898da382c7f55935" title="Get the transformation matrix representation of the Pose using OpenGL&#39;s transposed format...">GetMatrixGL</a>(d_marker.gl_mat, <span class="keyword">false</span>);
        GlutViewer::DrawableClear();
        GlutViewer::DrawableAdd(&amp;d_marker);
        own_drawable_count=0;

        <span class="comment">// Draw features</span>
        std::map&lt;int, SimpleSfM::Feature&gt;::iterator iter;
        iter = sfm-&gt;container.begin();
        <span class="keywordflow">for</span>(;iter != sfm-&gt;container.end(); iter++) {
                        <span class="keywordflow">if</span> (sfm-&gt;container_triangulated.find(iter-&gt;first) !=  sfm-&gt;container_triangulated.end()) <span class="keywordflow">continue</span>;
            <span class="keywordflow">if</span> (iter-&gt;second.has_p3d) 
            { 
                <span class="keywordflow">if</span> (own_drawable_count &lt; 1000) {
                    memset(d_points[own_drawable_count].gl_mat, 0, 16*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
                    d_points[own_drawable_count].gl_mat[0]  = 1;
                    d_points[own_drawable_count].gl_mat[5]  = 1;
                    d_points[own_drawable_count].gl_mat[10] = 1;
                    d_points[own_drawable_count].gl_mat[15] = 1;
                    d_points[own_drawable_count].gl_mat[12] = iter-&gt;second.p3d.x;
                    d_points[own_drawable_count].gl_mat[13] = iter-&gt;second.p3d.y;
                    d_points[own_drawable_count].gl_mat[14] = iter-&gt;second.p3d.z;
                    <span class="keywordflow">if</span> (iter-&gt;second.type_id == 0) d_points[own_drawable_count].SetColor(1,0,0);
                    <span class="keywordflow">else</span> d_points[own_drawable_count].SetColor(0,1,0);
                    GlutViewer::DrawableAdd(&amp;(d_points[own_drawable_count]));
                    own_drawable_count++;
                }
            }
        }

                <span class="comment">// Draw triangulated features</span>
        iter = sfm-&gt;container_triangulated.begin();
        <span class="keywordflow">for</span>(;iter != sfm-&gt;container_triangulated.end(); iter++) {
            <span class="keywordflow">if</span> (iter-&gt;second.has_p3d) 
            { 
                <span class="keywordflow">if</span> (own_drawable_count &lt; 1000) {
                    memset(d_points[own_drawable_count].gl_mat, 0, 16*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
                    d_points[own_drawable_count].gl_mat[0]  = 1;
                    d_points[own_drawable_count].gl_mat[5]  = 1;
                    d_points[own_drawable_count].gl_mat[10] = 1;
                    d_points[own_drawable_count].gl_mat[15] = 1;
                    d_points[own_drawable_count].gl_mat[12] = iter-&gt;second.p3d.x;
                    d_points[own_drawable_count].gl_mat[13] = iter-&gt;second.p3d.y;
                    d_points[own_drawable_count].gl_mat[14] = iter-&gt;second.p3d.z;
                    <span class="comment">/*if (iter-&gt;second.type_id == 0) d_points[own_drawable_count].SetColor(1,0,1);</span>
<span class="comment">                    else*/</span> d_points[own_drawable_count].SetColor(0,0,1);
                    GlutViewer::DrawableAdd(&amp;(d_points[own_drawable_count]));
                    own_drawable_count++;
                }
            }
        }
    }
    <span class="keywordflow">if</span> (image-&gt;nChannels == 1) cvCvtColor(image, rgb, CV_GRAY2RGB);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (image-&gt;nChannels == 3) cvCopy(image, rgb);

    <span class="comment">// Draw video on GlutViewer background</span>
    cvResize(rgb, bg_image);
    GlutViewer::SetVideo(bg_image);

    <span class="comment">// Draw debug info to the rgb</span>
    sfm-&gt;Draw(rgb);

    <span class="keywordflow">if</span> (flip_image) {
        cvFlip(image);
        image-&gt;origin = !image-&gt;origin;
    }
}


<span class="keywordtype">int</span> keycallback(<span class="keywordtype">int</span> key)
{
    <span class="keywordflow">if</span>(key == <span class="charliteral">&#39;r&#39;</span>)
    {
        reset = <span class="keyword">true</span>;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">return</span> key;

    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">try</span> {
        <span class="comment">// Output usage message</span>
        std::string filename(argv[0]);
        filename = filename.substr(filename.find_last_of(<span class="charliteral">&#39;\\&#39;</span>) + 1);
        std::cout &lt;&lt; <span class="stringliteral">&quot;SamplePointcloud&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;================&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Description:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  This example shows simple structure from motion approach that can be &quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  used to track environment beyond an multimarker setup. To get this   &quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  example work properly be sure to calibrate your camera and tune it   &quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  to have fast framerate without motion blur.                          &quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  There are two possible approaches Update() and UpdateRotationsOnly().&quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  By default the Update() is used but you can easily uncomment the     &quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  other one if needed.&quot;</span>&lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; [device]&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;    device    integer selecting device from enumeration list (default 0)&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;              highgui capture devices are prefered&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Keyboard Shortcuts:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  r: reset&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;  q: quit&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Initialise GlutViewer and CvTestbed</span>
        GlutViewer::Start(argc, argv, 640, 480, 100);
        CvTestbed::Instance().SetKeyCallback(keycallback);
        CvTestbed::Instance().SetVideoCallback(videocallback);
        sfm = <span class="keyword">new</span> <a class="code" href="classalvar_1_1_simple_sf_m.html" title="Simple structure from motion implementation using CameraEC , MarkerDetectorEC and TrackerFeaturesEC...">SimpleSfM</a>();

        <span class="comment">// Enumerate possible capture plugins</span>
        <a class="code" href="classalvar_1_1_capture_factory.html#ab20a5834d705078c79362de2de3965ad" title="Vector of strings.">CaptureFactory::CapturePluginVector</a> plugins = <a name="a7"></a><a class="code" href="classalvar_1_1_capture_factory.html#a2fc3b830862b08ee1d0a37eafb21d17d" title="The singleton instance of CaptureFactory.">CaptureFactory::instance</a>()-&gt;<a name="a8"></a><a class="code" href="classalvar_1_1_capture_factory.html#a328f78b1e9746642cd7f716ef1285363" title="Enumerate capture plugins currently available.">enumeratePlugins</a>();
        <span class="keywordflow">if</span> (plugins.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture plugins.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Display capture plugins</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Available Plugins: &quot;</span>;
        outputEnumeratedPlugins(plugins);
        std::cout &lt;&lt; std::endl;

        <span class="comment">// Enumerate possible capture devices</span>
        <a class="code" href="classalvar_1_1_capture_factory.html#a5851a2f3bcfb3bd6dcbbeb74235cf5f7" title="Vector of CaptureDevices.">CaptureFactory::CaptureDeviceVector</a> devices = <a class="code" href="classalvar_1_1_capture_factory.html#a2fc3b830862b08ee1d0a37eafb21d17d" title="The singleton instance of CaptureFactory.">CaptureFactory::instance</a>()-&gt;<a name="a9"></a><a class="code" href="classalvar_1_1_capture_factory.html#add65b61f92649d81df1eac0e97618a9a" title="Enumerate capture devices currently available.">enumerateDevices</a>();
        <span class="keywordflow">if</span> (devices.size() &lt; 1) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any capture devices.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 0;
        }

        <span class="comment">// Check command line argument for which device to use</span>
        <span class="keywordtype">int</span> selectedDevice = defaultDevice(devices);
        <span class="keywordflow">if</span> (argc &gt; 1) {
            selectedDevice = atoi(argv[1]);
        }
        <span class="keywordflow">if</span> (selectedDevice &gt;= (<span class="keywordtype">int</span>)devices.size()) {
            selectedDevice = defaultDevice(devices);
        }
        
        <span class="comment">// Display capture devices</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerated Capture Devices:&quot;</span> &lt;&lt; std::endl;
        outputEnumeratedDevices(devices, selectedDevice);
        std::cout &lt;&lt; std::endl;
        
        <span class="comment">// Create capture object from camera</span>
        <a name="_a10"></a><a class="code" href="classalvar_1_1_capture.html" title="Capture interface that plugins must implement.">Capture</a> *cap = <a class="code" href="classalvar_1_1_capture_factory.html#a2fc3b830862b08ee1d0a37eafb21d17d" title="The singleton instance of CaptureFactory.">CaptureFactory::instance</a>()-&gt;<a name="a11"></a><a class="code" href="classalvar_1_1_capture_factory.html#a7f7adc8e592218a92eb9108284073e67" title="Create Capture class. Transfers onwership to the caller.">createCapture</a>(devices[selectedDevice]);
        std::string uniqueName = devices[selectedDevice].uniqueName();

        <span class="comment">// Handle capture lifecycle and start video capture</span>
        <span class="comment">// Note that loadSettings/saveSettings are not supported by all plugins</span>
        <span class="keywordflow">if</span> (cap) {
            std::stringstream settingsFilename;
            settingsFilename &lt;&lt; <span class="stringliteral">&quot;camera_settings_&quot;</span> &lt;&lt; uniqueName &lt;&lt; <span class="stringliteral">&quot;.xml&quot;</span>;
            calibrationFilename &lt;&lt; <span class="stringliteral">&quot;camera_calibration_&quot;</span> &lt;&lt; uniqueName &lt;&lt; <span class="stringliteral">&quot;.xml&quot;</span>;
            
            cap-&gt;<a name="a12"></a><a class="code" href="classalvar_1_1_capture.html#ad64c54ab3191981b2443c47007f38516" title="Starts the camera capture.">start</a>();
            cap-&gt;<a name="a13"></a><a class="code" href="classalvar_1_1_capture.html#a7128319289dbf3e2847252407a636bf6" title="Set the resolution.">setResolution</a>(640, 480);
            
            <span class="keywordflow">if</span> (cap-&gt;<a name="a14"></a><a class="code" href="classalvar_1_1_capture.html#a485254ebd020e4976fe6ee8fbe14c964" title="Load camera settings from a file.">loadSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Loading settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            std::stringstream title;
            title &lt;&lt; <span class="stringliteral">&quot;SamplePointcloud (&quot;</span> &lt;&lt; cap-&gt;<a name="a15"></a><a class="code" href="classalvar_1_1_capture.html#acf46a70c9622fe7423877992d4cce3a8" title="The camera information associated to this capture object.">captureDevice</a>().<a name="a16"></a><a class="code" href="classalvar_1_1_capture_device.html#a11c32e9333ba254fb56e624f5f6fcade" title="The type of capture backend.">captureType</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;

            CvTestbed::Instance().StartVideo(cap, title.str().c_str());

            <span class="keywordflow">if</span> (cap-&gt;<a name="a17"></a><a class="code" href="classalvar_1_1_capture.html#af0e390628a628c31dce4bc8f48f7b847" title="Save camera settings to a file.">saveSettings</a>(settingsFilename.str())) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Saving settings: &quot;</span> &lt;&lt; settingsFilename.str() &lt;&lt; std::endl;
            }

            cap-&gt;<a name="a18"></a><a class="code" href="classalvar_1_1_capture.html#a0efff8623a2fb79dad94a96dcf16d966" title="Stops the camera capture.">stop</a>();
            <span class="keyword">delete</span> cap; cap = NULL;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CvTestbed::Instance().StartVideo(0, argv[0])) {
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Could not initialize the selected capture backend.&quot;</span> &lt;&lt; std::endl;
        }
        <span class="keyword">delete</span> sfm; sfm = NULL;

        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span> (...) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Exception: unknown&quot;</span> &lt;&lt; std::endl;
    }
}
</pre></div> </div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue May 29 2012 19:00:18 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
